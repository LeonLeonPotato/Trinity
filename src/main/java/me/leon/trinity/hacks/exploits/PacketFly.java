package me.leon.trinity.hacks.exploits;

import io.netty.util.internal.ConcurrentSet;
import me.leon.trinity.events.main.EventPacketSend;
import me.leon.trinity.events.main.MoveEvent;
import me.leon.trinity.events.main.RotationEvent;
import me.leon.trinity.hacks.Category;
import me.leon.trinity.hacks.Module;
import me.leon.trinity.setting.settings.Boolean;
import me.leon.trinity.setting.settings.Mode;
import me.leon.trinity.setting.settings.Slider;
import me.leon.trinity.setting.settings.sub.SubSlider;
import me.leon.trinity.utils.entity.PlayerUtils;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraftforge.fml.common.Mod;
import org.spongepowered.asm.mixin.injection.Slice;

import java.util.Random;
import java.util.Set;

public class PacketFly extends Module {
    public static Mode mode = new Mode("Mode", "Up", "Down", "Preserve", "Up");
    public static Boolean setBack = new Boolean("SetBack", true);
    public static Slider setBackTime = new Slider("SetBack Time", 2, 2, 20, true);
    public static Boolean fallPacket = new Boolean("FallPacket", true);
    public static Slider factor = new Slider("Factor", 0.5, 1, 2, false);
    public static Boolean noClip = new Boolean("NoClip", true);
    public static Boolean extra = new Boolean("Extra", true);
    public static Boolean doublePacket = new Boolean("DoublePacket", true);
    public static Boolean scan = new Boolean("Scan", true);
    public static Boolean confirm = new Boolean("Confirm", true);

    public PacketFly() {
        super("PacketFly", "Use packets to fly", Category.EXPLOITS);
    }

    private final Set<CPacketPlayer> packets = new ConcurrentSet<>();
    private int counter = 0;
    private int lastTp = -1;
    private final Random random = new Random();

    @Override
    public void onUpdate() {
        if(nullCheck()) {
            this.setEnabled(false);
        }
    }

    @EventHandler
    private final Listener<RotationEvent> listener0 = new Listener<>(event -> {
        CPacketPlayer.Position packet;
        int yOff = 0;
        int xOff = 0;
        int zOff = 0;

        switch (mode.getValue()) {
            case "Up": {
                yOff = 1337;
                break;
            }
            case "Down": {
                yOff = -1337;
                break;
            }
            case "Preserve": {
                xOff = random.nextInt(100000);
                zOff = random.nextInt(100000);
                break;
            }
        }

        double x = mc.player.posX + mc.player.motionX;
        double y = mc.player.posY + mc.player.motionY;
        double z = mc.player.posZ + mc.player.motionZ;

        if(extra.getValue()) {
            CPacketPlayer packet1 = new CPacketPlayer.Position(x, y, z, mc.player.onGround);
            packets.add(packet1);
            mc.player.connection.sendPacket(packet1);
        }

        packet = new CPacketPlayer.Position(x + xOff, y + yOff, z + zOff, mc.player.onGround);

        if(fallPacket.getValue()) {
            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
        }

        packets.add(packet);
        mc.player.connection.sendPacket(packet);
        if(doublePacket.getValue()) {
            mc.player.connection.sendPacket(packet);
        }

        if(confirm.getValue()) {
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.lastTp + 1));
            ++this.lastTp;
        }
    });

    @EventHandler
    private final Listener<MoveEvent> eventMove = new Listener<>(event -> {
        if(nullCheck()) return;

        this.counter++;
        mc.player.setVelocity(0, 0, 0);

        if(noClip.getValue()) {
            mc.player.noClip = true;
        }

        PlayerUtils.doStrafe(getSpeed());
        mc.player.motionY = event.y = getY();
        event.x = mc.player.motionX;
        event.z = mc.player.motionZ;

        event.cancel();
    });

    private boolean checkHitBoxes() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    private float getY() {
        if(mc.gameSettings.keyBindJump.isKeyDown() && mc.gameSettings.keyBindSneak.isKeyDown()) {
            return 0f;
        }
        if(mc.gameSettings.keyBindJump.isKeyDown()) {
            return getSpeed();
        }
        if(mc.gameSettings.keyBindSneak.isKeyDown()) {
            return -getSpeed();
        }
        return 0.0f;
    }

    @EventHandler
    private final Listener<EventPacketSend> sendListener = new Listener<>(event -> {
        if(scan.getValue()) {
            if(event.getPacket() instanceof CPacketPlayer) {
                if(!packets.contains(event.getPacket())) {
                    event.cancel();
                }
            }
        }
    });

    @Override
    public void onDisable() {
        this.packets.clear();
        this.lastTp = -1;
    }

    private float getSpeed() {
        if(setBack.getValue()) {
            if(counter >= setBackTime.getValue()) {
                this.counter = 0;
                return (float) ( -(checkHitBoxes() ? 0.036 : 0.062) * factor.getValue());
            }
        }
        return (float) ((checkHitBoxes() ? 0.036 : 0.062) * factor.getValue());
    }

    @Override
    public boolean shouldSave() {
        return false;
    }
}
